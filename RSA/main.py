from mpmath import *

def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    g, y, x = egcd(b%a,a)
    return (g, x - floor(b/a) * y, y)

def modInverse(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('No modular inverse')
    return x%m

def mod(num, a): 
      
    # Initialize result 
    res = 0
  
    # One by one process all digits 
    # of 'num' 
    for i in range(0, len(num)): 
        res = (res * 10 + int(num[i])) % a; 
  
    return res

mp.prec=800
mp.dps=500

N=mp.mpf(179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581)

A=int(ceil(mp.sqrt(N))) #arithmetic mean of p and q
x=mp.sqrt(power(A, 2)-N)
print(A-x) #ans for part 1
p=A-x
q=A+x
print("\n\n")

N=mp.mpf(648455842808071669662824265346772278726343720706976263060439070378797308618081116462714015276061417569195587321840254520655424906719892428844841839353281972988531310511738648965962582821502504990264452100885281673303711142296421027840289307657458645233683357077834689715838646088239640236866252211790085787877)

# for A in range(int(ceil(mp.sqrt(N))), int(N)):
# 	x=mp.sqrt(power(A, 2)-N)
# 	if (x-int(x)) == 0:
# 		p=A-x
# 		q=A+x

# 		if int(p*q) == int(N):
# 			print("Found prime: ", p) #ans for part 2
# 			break
# print("\n\n")

N=mp.mpf(720062263747350425279564435525583738338084451473999841826653057981916355690188337790423408664187663938485175264994017897083524079135686877441155132015188279331812309091996246361896836573643119174094961348524639707885238799396839230364676670221627018353299443241192173812729276147530748597302192751375739387929)
A=ceil(mp.sqrt(24*N))
x=mp.sqrt(power(A, 2)-24*N)
print((A-x)/6) #ans part 3
print("\n\n")

ciphertext=mp.mpf(22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256465839967942889460764542040581564748988013734864120452325229320176487916666402997509188729971690526083222067771600019329260870009579993724077458967773697817571267229951148662959627934791540)
e=mp.mpf(65537)
N=mp.mpf(179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581)
totient=N-p-q+1
d=modInverse(e, totient)
k=floor((e*d-1)/totient)
decrypted=pow(int(ciphertext), int(d), int(N))
ba=decrypted.to_bytes(500, 'big')
message=[]

for b in range(len(ba)-1, 0, -1):
	message.insert(0, chr(ba[b]))
	if ba[b]==0:
		break

print(message)